--- irgen/ssa.go
+++ irgen/ssa.go
@@ -402,7 +402,7 @@
 	// an unwind block. We can short-circuit the check for defers with
 	// f.Recover != nil.
 	if f.Recover != nil || hasDefer(f) {
-		fr.unwindBlock = llvm.AddBasicBlock(fr.function, "")
+		fr.unwindBlock = llvm.AddBasicBlock(fr.function, "unwind")
 		fr.frameptr = fr.builder.CreateAlloca(llvm.Int8Type(), "")
 	}
 
@@ -432,7 +432,7 @@
 	fr.fixupPhis()
 
 	if !fr.unwindBlock.IsNil() {
-		fr.setupUnwindBlock(f.Recover, f.Signature.Results())
+		fr.setupUnwindBlock(f.Recover)
 	}
 
 	// The init function needs to register the GC roots first. We do this
@@ -623,19 +623,12 @@
 	fr.runtime.undefer.invoke(fr, retrylpad, fr.frameptr)
 }
 
-func (fr *frame) setupUnwindBlock(rec *ssa.BasicBlock, results *types.Tuple) {
-	recoverbb := llvm.AddBasicBlock(fr.function, "")
+func (fr *frame) setupUnwindBlock(rec *ssa.BasicBlock) {
+	var recoverbb llvm.BasicBlock
 	if rec != nil {
-		fr.translateBlock(rec, recoverbb)
-	} else if results.Len() == 0 || results.At(0).Anonymous() {
-		// TODO(pcc): Remove this code after https://codereview.appspot.com/87210044/ lands
-		fr.builder.SetInsertPointAtEnd(recoverbb)
-		values := make([]llvm.Value, results.Len())
-		for i := range values {
-			values[i] = llvm.ConstNull(fr.llvmtypes.ToLLVM(results.At(i).Type()))
-		}
-		fr.retInf.encode(llvm.GlobalContext(), fr.allocaBuilder, fr.builder, values)
+		recoverbb = fr.blocks[rec.Index]
 	} else {
+		recoverbb = llvm.AddBasicBlock(fr.function, "recover")
 		fr.builder.SetInsertPointAtEnd(recoverbb)
 		fr.builder.CreateUnreachable()
 	}
